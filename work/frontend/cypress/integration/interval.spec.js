/**
 * STRING_COMPETITION STRING_YEAR - STRING_TRADE - STRING_TITLE
 * Frontend - Task 1
 *
 * This file contains the unit tests performed on the frontend task.
 * You may look at the test cases but not modify them.
 *
 * !!! DO NOT EDIT THIS FILE !!!
 */

const Interval = require('../../src/interval.js')

describe('Interval', () => {
    it('can instantiate an interval', () => {
        cy.clock().then((clock) => {
            let count = 0

            new Interval(() => {
                count++
            }, 1000)

            expect(count).to.equal(0)
            clock.tick(5000)
            expect(count).to.equal(0)
        })
    })

    it('can start an interval', () => {
        cy.clock().then((clock) => {
            let count = 0

            const interval = new Interval(() => {
                count++
            }, 1000)
            interval.start()

            expect(count).to.equal(0)
            clock.tick(500)
            expect(count).to.equal(0)
            clock.tick(500)
            expect(count).to.equal(1)
            clock.tick(1000)
            expect(count).to.equal(2)
            clock.tick(1000)
            expect(count).to.equal(3)
        })
    })

    it('can pause an interval', () => {
        cy.clock().then((clock) => {
            let count = 0

            const interval = new Interval(() => {
                count++
            }, 1000)
            interval.start()

            expect(count).to.equal(0)
            clock.tick(500)
            expect(count).to.equal(0)
            clock.tick(500)
            expect(count).to.equal(1)

            interval.pause()
            clock.tick(1000)
            expect(count).to.equal(1)
        })
    })

    it('can continue an interval', () => {
        cy.clock().then((clock) => {
            let count = 0

            const interval = new Interval(() => {
                count++
            }, 1000)
            interval.start()

            interval.pause()
            clock.tick(1000)
            expect(count).to.equal(0)

            interval.continue()
            clock.tick(1000)
            expect(count).to.equal(1)
        })
    })

    it('can call the callback with the correct number of milliseconds since the last call', () => {
        cy.clock().then((clock) => {
            const callback = cy.stub()

            const interval = new Interval(callback, 500)
            interval.start()

            clock.tick(500)
            expect(callback).to.be.called.calledWithExactly(500)
            callback.reset()

            clock.tick(200)
            expect(callback).not.to.be.called
            callback.reset()

            clock.tick(300)
            expect(callback).to.be.called.calledWithExactly(500)
        })
    })

    it('can continue an interval at the correct millisecond', () => {
        cy.clock().then((clock) => {
            let count = 0

            const interval = new Interval(() => {
                count++
            }, 1000)
            interval.start()

            clock.tick(900)
            interval.pause()
            clock.tick(1000)
            expect(count).to.equal(0)

            interval.continue()
            clock.tick(100)
            expect(count).to.equal(1)
        })
    })
})
